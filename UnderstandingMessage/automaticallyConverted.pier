
!!Hints for identifying keyword messages

Often beginners have problems understanding when they need to add parentheses. Let's see how keywords messages are recognized by the compiler.

!!!Parentheses or not?

The characters ==[}, \ct{]==, ==(} and \ct{)==
delimit distinct areas. Within such an area, a keyword message is the longest sequence of words terminated  by ==:== that is not cut by the characters ==.==,  or ==;==.
When the characters ==[}, \ct{]==, ==(} and \ct{)== surround some words with colons, these words participate in the keyword message ''local'' to the area defined.

In this example, there are two distinct keyword messages:  ==rotatedBy:magnify:smoothing:== and ==at:put:==.

[[[
aDict
   at: (rotatingForm
          rotateBy: angle
          magnify: 2
          smoothing: 1)
   put: 3
]]]

\important{
The characters ==[}, \lct{]==, ==(} and \lct{)== delimit distinct areas. Within such an area,
a keyword message is the longest sequence  of words terminated by ==:== that is not cut by the characters ==.==,  or ==;==.
When the characters ==[}, \lct{]==, ==(} and \lct{)== surround some words with colons, these words participate in the keyword message local to the area defined.}



!!!!!Hints.
 If you have problems with these precedence rules, you may start simply by putting parentheses whenever you want to distinguish two messages having the same precedence.

The following piece of code does not require parentheses because the message send  ==x isNil== is unary hence is sent prior to the keyword message ==ifTrue:==.
[[[
(x isNil)
   ifTrue:[...]
]]]

The following piece of code requires parentheses because the messages ==includes:== and ==ifTrue:== are both keyword messages.
[[[
ord := OrderedCollection new.
(ord includes: $a)
   ifTrue:[...]
]]]

Without parentheses the unknown message ==includes:ifTrue:== would be sent to the collection!

!!!When to use ==[ ]== or ==( )==

You may also have problems understanding when to use square brackets rather than parentheses.
The basic principle is that you should use ==[ ]== when you do not know how many times, potentially zero, an expression should be evaluated.
==[''expression'']== will create a \ind{block} closure (''i.e.'', an object) from ==''expression''==, which may be evaluated any number of times (possibly zero), depending on the context. Here note that an expression can either be a message send, a variable, a literal, an assignment or a block.

Hence the conditional branches of ==ifTrue:== or ==ifTrue:ifFalse:== require blocks. Following the same principle both the receiver and the argument of a ==whileTrue:== message require the use of square brackets since we do not know how many times either the receiver or the argument should be evaluated.

Parentheses, on the other hand, only affect the order of sending messages.
So in ==(''expression'')==, the ==''expression''== will ''always'' be evaluated exactly once.

[[[
[ x isReady ] whileTrue: [ y doSomething ]   "both the receiver and the argument must be blocks"
4 timesRepeat: [ Beeper beep ]                   "the argument is evaluated more than once, so must be a block"
(x isReady) ifTrue: [ y doSomething ]           "receiver is evaluated once, so is not a block"
]]]

!!Expression sequences

Expressions (''i.e.'', message sends, assignments\dots) separated by periods are evaluated in sequence.
Note that there is no period between a variable definition and the following expression.
The value of a sequence is the value of the last expression. The values returned by all the
expressions except the last one are ignored. Note that the period is a \subind{statement}{separator} and not a terminator. Therefore a final period is optional.

[[[
| box |
box := 20@30 corner: 60@90.
box containsPoint: 40@50 --> true
]]]

!!Cascaded messages

\st offers a way to send multiple messages to the same receiver using a semicolon (==;==). This is called the \emphind{cascade} in \st jargon.

\important{Expression Msg1 ; Msg2}

\begin{minipage}{0.35\textwidth}
[[[
Transcript show: 'Pharo is '.
Transcript show: 'fun '.
Transcript cr.
]]]
\end{minipage}
''is equivalent to:''
\begin{minipage}{0.35\textwidth}
[[[
Transcript
   show: 'Pharo is';
   show: 'fun ';
   cr
]]]
\end{minipage}

Note that the object receiving the cascaded messages can itself be the result of a message send.
In fact the receiver of all the cascaded messages is the receiver of the first message involved in a cascade. In the following example, the first cascaded message is ==setX:setY== since it is followed by a cascade. The receiver of the cascaded message ==setX:setY:== is the newly created point resulting from the evaluation of ==Point new==, and ''not'' ==Point==. The subsequent message ==isZero== is sent to that same receiver.

[[[
Point new setX: 25 setY: 35; isZero --> false
]]]

!!Chapter summary


-A message is always sent to an object named the ''receiver'' which may be the result of other message sends.
-Unary messages are messages that do not require any argument.\\ They are of the form of ==receiver \textbf{selector}==.
-Binary messages are messages that involve two objects, the receiver and another object ''and'' whose selector is composed of one or more characters from the following list: ==+==, ==-==, ==*==, ==/==, ==|==, \texttt{\&}, =====, ==>==, ==<==, \texttt{\~}, and ==@==.  They are of the form: ==receiver \textbf{selector} argument==
-Keyword messages are messages that involve more than one object and that contain at least one colon character (==:==). \\ They are of the form: ==receiver \textbf{selectorWordOne:} argumentOne \textbf{wordTwo:} argumentTwo==
-\textbf{Rule One.} Unary messages are sent first, then binary messages, and finally keyword messages.
-\textbf{Rule Two.} Messages in parentheses are sent before any others.
-\textbf{Rule Three.} When the messages are of the same kind, the order of evaluation is from left to right.
-In \st, traditional arithmetic operators such as + and * have the same priority. ==+== and ==*== are just binary messages, therefore ==*== does not have priority over ==+==. You must use parentheses to obtain a different result.
