

##The Smalltalk object model

<a name="cha:model"></a>

Smalltalk's programming model is simple and uniform: everything is an object, and objects communicate only by sending each other messages\.
However, this simplicity and uniformity can be a source of difficulty for programmers used to other languages\. In this chapter we present the core concepts of the Smalltalk object model; in particular we discuss the consequences of representing classes as objects\.



###1\. The rules of the model

<a name="sec:rules"></a>

The Smalltalk object model is based on a set of simple
rules that are applied *uniformly*\. The rules are as follows:



-  **Rule 1**\. Everything is an object\.
-  **Rule 2**\. Every object is an instance of a class\.
-  **Rule 3**\. Every class has a superclass\.
-  **Rule 4**\. Everything happens by sending messages\.
-  **Rule 5**\. Method lookup follows the inheritance chain\.



Let us look at each of these rules in some detail\.




###2\. Everything is an Object



The mantra *everything is an object* is highly contagious\.
After only a short while working with Smalltalk, you will start to be surprised at how this rule simplifes everything you do\.
Integers, for example, are truly objects, so you can send messages to them, just as you do to any other object\.



```smalltalk
3 + 4            --> 7    "send '+ 4' to 3, yielding 7"
20 factorial  --> 2432902008176640000   "send factorial, yielding a big number"
```



The representation of `20 factorial` is certainly different from the representation of `7`, but because they are both objects, none of the code ,not even the implementation of `factorial`, needs to know about this\.


Perhaps the most fundamental consequence of this rule is the following:
&nbsp;<p class="important">**Classes are objects too\.**</p>Furthermore, classes are not second\-class objects: they are really first\-class objects that you can send messages to, inspect, and so on\.
This means that Pharo is a truly reflective system, which gives a great deal of expressive power to developers\.

Deep in the implementation of Smalltalk, there are three different kinds of objects\.  There are \(1\) ordinary objects with instance variables that are passed by references, there are \(2\) *small integers* that are passed by value, and there are \(3\) indexable objects like arrays that hold a contiguous portion of memory\.  The beauty of Smalltalk is that you normally don't need to care about the differences between these three kinds of object\.












































































































































































































































































